## Building interfaces in JSON using CLAP

Although it is possible to write interfaces in native Python CLAP also
supports building them from JSON files. 
Sometimes it's easier (and it's generally good idea) to keep interface
separate from logic code. Also, when you are making diffs or updates then it'll
be easier to spot interface updates.

----

### Limitations of JSON interfaces

There is no method to access Python data types from JSON because it would violate
the syntax of JSON.


----

### Handling option types

Virtually every type can be accessed without much hassle - via *type-handlers*.
In JSON types are represented as strings - `"str"` or `"int"` for example.

`Builder()` object has `addTypeHandler()` method which is used for assigning strings
to their callback functions.

**USAGE**: `Builder().addTypeHandler('string-identifer', some.callback.function)`

Type handler is added to builder like this:

    builder = clap.builder.Builder('/path/to/fancy/ui.json', argv=[...])
    builder.addTypeHandler('str', str)
    builder.addTypeHandler('float', float)
    ...

You have to add handler for every data type used in your interface or it won't be built.

Note that you don't've to add type handlers for `str`, `int` and `float` types.


----

### JSON descriptions of UI elements

#### 1. Option

Options are represented in JSON as dictionaries and appended to their parsers using
the handy feature of dictionary expansion (or something like this I cannot force myself
to memorize the name) - `parser.add(**option)`.

Example option (covering all possible fields):

    {
        "short": "f",
        "long": "foo",
        "arguments": ["str", "int", "float"],
        "conflicts": ["--bar"],
        "requires": ["--baz"],
        "needs": ["--bax", "--bay"],
        "required": true,
        "not_with": ["--spam"],
    }


`isoption()` function in `clap.builder` is used to check if a dict is valid option.

----

#### 2. Parser

Parser is just a list of options.

    [
        {
            "short": "f",
            "long": "foo"
        },
        {
            "short": "b",
            "long": "bar",
            "arguments": ["int"],
        }
    ]

----

#### 3. Modes Parser

Modes parser is represented by a JSON dictionary in which each name is a name of a
mode. Each mode is a parser (so a list of options).

Keep in mind that there are few reserved keys:

*   `short`:        is reserved because of current implementation of type detection
                    (CLAP must make distinction between modes parser and option),
*   `long`:         see above,
*   `__global__`:   a list of global options (applied to all modes),

This list may be a subject to change if CLAP will gain some new functionality (new keys may
be added) or when some more sophisticated type-detection will be implemented (`short` and `long`
may be removed from the list - but this is highly unlikely).

Example:

    {
        "door": [
            {
                "short": "s",
                "long": "shut"
            },
            {
                "short": "r",
                "long": "ring-the-bell"
            }
        ],
        "window": [
            {
                "short": "b",
                "long": "break"
            },
            {
                "short": "l",
                "long": "look-through"
            }
        ],
        "__global__": [
            {
                "short": "o",
                "long": "open"
            },
            {
                "short": "c",
                "long": "close"
            }
        ]
    }

Nested modes are created by assigning another dict representing mode parser to a mode name.

Not that `__global__` mode must be a simple list of option and cannot be a modes-parser.


----

### Reference implementations

In main directory of CLAP library there are files containing example in their names.
They are reference implementations of builders and example JSON interfaces which you can read and
make yourself more knowledgeable about usage of CLAP.
