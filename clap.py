#!/usr/bin/env python3

"""command line arguments parser"""

import sys

__version__ = "0.0.2"

class UnexpectedOptionError(Exception): pass
class SwitchValueError(Exception): pass
class NotParsedError(Exception): pass
class OptionNotFoundError(LookupError): pass

class Parser():
    def __init__(self, short="", long=[], argv=[]):
        self.setshort(short)
        self.setlong(long)
        self.setargv(argv)
        self.opts, self.args = ([], [])
        self.parsed = False
    
    def _splitshorts(self):
        """
        This method scans items passed from command line and splits any short options passed together eg. 
        '-lhR'. It this case the '-lhR' will become '-l', '-h', '-R'. 
        Connecting options that require a value is forbidden.
        """
        argv = []
        n = 0
        for i, arg in enumerate(self.argv):
            if self._areopts([ "-{0}".format(opt) for opt in list(arg)[1:] ], mode="s") and arg[0] == "-" and arg != "--": 
                arg = [ "-{0}".format(opt) for opt in list(arg)[1:] ]
            elif arg == "--":
                argv.append("--")
                n = i
                break
            else:
                arg = [arg]
            argv.extend(arg)
            n = i
        self.argv = argv + self.argv[i+1:]

    def _areopts(self, opts, mode="b"):
        """
        Checks if given list contain only options accepted by this instance of Parser(). 
        You have to pass it in full form eg. `--verbose` and `-v`. 
        Value indicator (`:`) has to be explicitly given. 
        
        Modes are:
         *  's' - for short options,
         *  'l' - for long options,
         *  'b' - for types,
        """
        result = True
        for opt in opts:
            result = self.isopt(opt, mode=mode)
            if not result: break
        return result

    def _parseopts(self):
        """
        Parses options from the command line and assigns values to them if needed.
        """
        opts = []
        i = 0
        while i < len(self.argv):
            opt = self.argv[i]
            if opt == "--":
                i += 1
                break
            elif self.isopt(opt):
                value = ""
            elif self.isopt("{0}:".format(opt)):
                i += 1
                if len(self.argv) <= i: raise SwitchValueError("'{0}' option requires a value but run out of arguments".format(opt))
                else: value = self.argv[i]
            elif opt[0] == "-":
                raise UnexpectedOptionError("unexpected option found: {0}".format(opt))
            else:
                break
            opts.append( (opt, value) )
            i += 1
        self.opts = opts
        return i
    
    def setshort(self, opts):
        """
        Sets short options. Accepts string.
        """
        shorts = []
        for i, opt in enumerate(opts):
            try:
                if opts[i+1] == ":": opt += ":"
            except IndexError: 
                pass
            finally:
                if opt != ":": shorts.append("-{0}".format(opt))
        self.descript_short = shorts

    def setlong(self, opts):
        """
        Sets long options. Accepts list of strings.
        """
        self.descript_long = opts

    def setargv(self, argv):
        """
        Sets list of arguments from command line or custom made (eg. generated by a client program).
        """
        self.argv = argv

    def getshorts(self):
        """
        Returns list of short options accepted by this instance of Parser().
        """
        return self.descript_short
    
    def getlongs(self):
        """
        Returns list of long options accepted by this instance of Parser().
        """
        return [ "--{0}".format(opt) for opt in self.descript_long ]
    
    def isopt(self, opt, mode="b"):
        """
        Checks if given string is a valid option for this instance of Parser(). 
        You have to pass it in full form eg. `--verbose` and `-v`. 
        Value indicator (`:`) has to be explicitly given. 
        
        Modes are:
         *  's' - for short options,
         *  'l' - for long options,
         *  'b' - for both types,
        """
        if mode == "s": result = opt in self.descript_short
        elif mode == "l": result = opt[2:] in self.descript_long
        else: result = self.isopt(opt, mode="s") or self.isopt(opt, mode="l")
        return result

    def parse(self):
        """
        Parses contents of `argv` and splits them into options and arguments.
        """
        #   _parseopts() returns index at which it stopped parsing options 
        #   this means that after this index there are only arguments
        self._splitshorts()
        n = self._parseopts()
        self.args = self.argv[n:]
        self.parsed = True
    
    def listaccepted(self):
        """
        Returns list of options by this instance of Parser().
        """
        opts = []
        for opt in self.descript_short: opts.append(opt)
        for opt in self.descript_long: opts.append( "--{0}".format(opt) )
        while "--" in opts: opts.remove("--")
        return opts

    def waspassed(self, opt, *args):
        """
        Checks if the given option was passed.
        Returns `True` if any of given options have been passed.
        """
        args += (opt,)
        result = False
        for opt in args:
            if opt in self.getpassed():
                result = True
                break
        return result
        
    def getpassed(self):
        """
        Returns list of options passed to this instance of Parser().
        """
        if not self.parsed: raise NotParsedError("getpassed() used on object with unparsed options")
        return [ opt for opt, value in self.opts ]

    def getopt(self, opt):
        """
        Returns options value or empty string if the option does not accept values.
        Raises OptionNotFoundError if option has not been found.
        """
        value = None
        for optkey, optvalue in self.opts:
            if optkey == opt:
                value = optvalue
                break
        if value == None: raise OptionNotFoundError("'{0}' not found in passed options".format(opt))
        return value

    def getargs(self):
        """
        Returns list of arguments passed from command line.
        """
        return self.args


class NewParser():
    """
    Class utilizing methods used for parsing input from command line.
    """
    
    def __init__(self, short="", long=[], argv=[]):
        self._argv = argv
        self._short, self._long = (short, long)
        self._options, self._arguments = ([], [])
    
    def _formatshorts(self):
        """
        Method responsible for formatting short options list given to parser.
        """
        short, i = ([], 0)
        while i < len(self._short):
            option, n = ("-{0}", 1)
            try:
                if self._short[i+1] == ":":
                    n += 1
                    option += ":"
            except IndexError: 
                pass
            finally:
                short.append(option.format(self._short[i]))
            i += n
        self._short = short
    
    def _formatlongs(self):
        """
        Method responsible for formatting long options list given to parser.
        """
        self._long = [ "--{0}".format(opt) for opt in self._long ]
    
    def _isopt(self, option, mode="b"):
        """
        Returns True if given option is accepted by thi instance of NewParser().
        Modes are:
        'b' - for both types of options,
        's' - for short options,
        'l' - for long options,
        """
        if mode == "s": result = option in self._short
        elif mode == "l": result = option in self._long
        else: result = option in self._short or option in self._long
        return result
    
    def format(self):
        """
        Formats options lists given to Parser().
        Has to be called before parse().
        """
        self._formatshorts()
        self._formatlongs()
        
    def purge(self):
        """
        Resets *every* variable to empty state.
        """
        self._argv = []
        self._short, self._long = ("", [])
        self._options, self._arguments = ([], [])

    def clean(self):
        """
        Cleans parser - resets everything except `_argv`.
        """
        self._short, self._long = ("", [])
        self._options, self._arguments = ([], [])

    def addshort(self, option):
        """
        Appends option to list of recognized short options.
        """
        option = "-{0}".format(option)
        self.rmshort(option)
        self._short.append(option)

    def addlong(self, option):
        """
        Appends option to list of recognized short options.
        """
        option = "--{0}".format(option)
        self.rmlong(option)
        self._long.append(option)

    def rmshort(self, option):
        """
        Removes option from list of recognized short options.
        """
        if self._isopt(option): self._short.remove(option)
        elif self._isopt("{0}:".format(option)): self._short.remove("{0}:".format(option))
        elif self._isopt(option[:-1]): self._short.remove(option[:-1])

    def rmlong(self, option):
        """
        Removes option from list of recognized short options.
        """
        if self._isopt(option): self._long.remove(option)
        elif self._isopt("{0}=".format(option)): self._long.remove("{0}=".format(option))
        elif self._isopt(option[:-1]): self._long.remove(option[:-1])
    
    def parse(self):
        """
        Parses command line input to options and arguments.
        """
        options, arguments, i = ([], [], 0)
        while i < len(self._argv):
            option, argument = (self._argv[i], "")
            if self._isopt(option): 
                pass
            elif self._isopt("{0}:".format(option)) or self._isopt("{0}=".format(option)):
                i += 1
                argument = self._argv[i]
            elif option == "--":
                arguments = self._argv[i+1:]
                break
            elif option[0] == "-" and option != "-":
                raise UnexpectedOptionError("unexpected option found: {0}".format(option))
            else:
                arguments = self._argv[i:]
                break
            options.append( (option, argument) )
            i += 1
        self._options = options
        self._arguments = arguments


class Interface():
    """
    Clients should use this class as it provides an interface 
    to the internal methods and logic.
    """
    
    def __init__(self, short="", long=[], argv=[]):
        self._parser, self._parsed = (NewParser(short=short, long=long, argv=argv), False)

    def parse(self):
        """
        Parses given command line input.
        """
        self._parser.format()
        self._parser.parse()
        self._parsed = True
